<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pac-Man Estilo Azul</title>
  <style>
  body {
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #222;
    font-family: Arial, sans-serif;
    color: white;
  }
  canvas {
    background-color: #0000FF; /* Fundo azul escuro */
    display: block;
    margin: 20px auto;
    border: 2px solid #0000FF;
    cursor: pointer;
  }
  #score {
    font-size: 24px;
    margin-bottom: 5px;
  }
  #power-timer {
    font-size: 18px;
    color: yellow;
    height: 20px;
  }
  #message {
    font-size: 18px;
    color: #FF0000;
    height: 20px;
  }
  </style>
</head>
<body>
  <h1>Pac-Man Estilo Azul</h1>
  <div id="score">Pontos: 0</div>
  <div id="power-timer"></div>
  <div id="message"></div>
  <div id="startScreen" style="position: relative; width: 600px; height: 400px; background: url('assets/logo.jpg') center/cover; border: 2px solid #0000FF; cursor: pointer; display: flex; align-items: center; justify-content: center;">
    <div style="background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; text-align: center;">
      <h2 style="color: #FFFF00; margin: 0 0 10px 0;">CLIQUE PARA JOGAR</h2>
      <p style="color: white; margin: 0;">Use as setas ou mouse para se mover</p>
    </div>
  </div>
  <canvas id="gameCanvas" width="600" height="400" style="display: none;"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const timerElement = document.getElementById('power-timer');
    const messageElement = document.getElementById('message');
    // Web Audio API
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    // Cores
    const cores = {
      azul: '#0000FF',
      vermelho: '#FF0000',
      cinza: '#AAAAAA',
      amarelo: '#FFFF00',
      dot: '#00FFFF',
      preto: '#000000'
    };
    // Pac-Man
    let pacManX = 300;
    let pacManY = 200;
    const pacManRadius = 30;
    // Velocidade
    const pacSpeed = 3;
    // Teclado
    const keys = {};
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });
    // Mouse
    let mouseX = pacManX;
    let mouseY = pacManY;
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });
    // Fantasma
    let ghost = {
      x: 100,
      y: 100,
      radius: 26,
      speed: 2.2
    };
    // Dots
    const dots = [];
    const dotRadius = 6;
    // Power-up
    let powerUp = { x: -50, y: -50 };
    const powerUpRadius = 10;
    let powerUpActive = false;
    let powerUpTimer = 0;
    let powerUpVisible = false;
    // Partículas de explosão
    const particles = [];
    function createParticle(x, y, color) {
      return {
        x, y,
        vx: (Math.random() - 0.5) * 8,
        vy: (Math.random() - 0.5) * 8,
        radius: Math.random() * 3 + 2,
        color,
        alpha: 1,
        decay: Math.random() * 0.05 + 0.02
      };
    }
    function explode(x, y, color, count = 15) {
      for (let i = 0; i < count; i++) {
        particles.push(createParticle(x, y, color));
      }
    }
    function createDots() {
      dots.length = 0;
      for (let i = 0; i < 20; i++) {
        let x, y;
        let overlap;
        do {
          overlap = false;
          x = dotRadius * 3 + Math.random() * (canvas.width - dotRadius * 6);
          y = dotRadius * 3 + Math.random() * (canvas.height - dotRadius * 6);
          if (Math.hypot(x - pacManX, y - pacManY) < 50) {
            overlap = true;
            continue;
          }
          for (const dot of dots) {
            if (Math.hypot(dot.x - x, dot.y - y) < 30) {
              overlap = true;
              break;
            }
          }
        } while (overlap);
        dots.push({ x, y });
      }
    }
    function spawnPowerUp() {
      let x, y;
      do {
        x = powerUpRadius * 2 + Math.random() * (canvas.width - powerUpRadius * 4);
        y = powerUpRadius * 2 + Math.random() * (canvas.height - powerUpRadius * 4);
      } while (
        Math.hypot(x - pacManX, y - pacManY) < 50 ||
        dots.some(dot => Math.hypot(dot.x - x, dot.y - y) < 30)
      );
      powerUp = { x, y };
      powerUpVisible = true;
    }
    createDots();
    setTimeout(spawnPowerUp, 3000);
    let score = 0;
    let ghostSoundActive = false;
    let ghostSoundOsc = null;
    let ghostSoundGain = null;
    // Função para tocar som
    function playSound(frequency, duration, type = 'sine', volume = 0.2) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    // Som de tensão (fantasma próximo)
    function startGhostTensionSound() {
      if (ghostSoundActive || !audioCtx) return;
      ghostSoundActive = true;
      ghostSoundOsc = audioCtx.createOscillator();
      ghostSoundGain = audioCtx.createGain();
      ghostSoundOsc.type = 'sawtooth';
      ghostSoundOsc.frequency.setValueAtTime(120, audioCtx.currentTime);
      ghostSoundGain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      ghostSoundOsc.connect(ghostSoundGain);
      ghostSoundGain.connect(audioCtx.destination);
      ghostSoundOsc.start();
    }
    function updateGhostTensionSound(distance) {
      if (!ghostSoundActive) return;
      const minDist = 100;
      const maxVol = 0.2;
      const vol = Math.max(0, (minDist - distance) / minDist) * maxVol;
      if (ghostSoundGain) {
        ghostSoundGain.gain.setValueAtTime(vol, audioCtx.currentTime);
      }
    }
    function stopGhostTensionSound() {
      if (ghostSoundActive && ghostSoundOsc) {
        ghostSoundOsc.stop();
        ghostSoundOsc = null;
        ghostSoundGain = null;
        ghostSoundActive = false;
      }
    }
    // Animação da boca
    let mouthOpen = true;
    let mouthAngle = 0.2;
    function resetGame() {
      score = 0;
      scoreElement.textContent = `Pontos: ${score}`;
      messageElement.textContent = "Você foi pego! Reiniciando...";
      setTimeout(() => {
        messageElement.textContent = "";
        pacManX = 300;
        pacManY = 200;
        ghost.x = 100;
        ghost.y = 100;
        createDots();
        if (!powerUpActive) spawnPowerUp();
      }, 1000);
    }
    // Loop principal
    function loop() {
      // Atualiza temporizador
      if (powerUpActive) {
        powerUpTimer -= 1/60;
        if (powerUpTimer <= 0) {
          powerUpActive = false;
          timerElement.textContent = "";
        } else {
          timerElement.textContent = `Power: ${Math.ceil(powerUpTimer)}s`;
        }
      } else {
        timerElement.textContent = "";
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Movimento do Pac-Man
      if (keys['ArrowUp'] && pacManY > pacManRadius) pacManY -= pacSpeed;
      if (keys['ArrowDown'] && pacManY < canvas.height - pacManRadius) pacManY += pacSpeed;
      if (keys['ArrowLeft'] && pacManX > pacManRadius) pacManX -= pacSpeed;
      if (keys['ArrowRight'] && pacManX < canvas.width - pacManRadius) pacManX += pacSpeed;
      if (!keys['ArrowUp'] && !keys['ArrowDown'] && !keys['ArrowLeft'] && !keys['ArrowRight']) {
        const dx = mouseX - pacManX;
        const dy = mouseY - pacManY;
        const dist = Math.hypot(dx, dy);
        if (dist > 1) {
          pacManX += (dx / dist) * pacSpeed;
          pacManY += (dy / dist) * pacSpeed;
        }
      }
      // Distância até o fantasma
      const dxG = pacManX - ghost.x;
      const dyG = pacManY - ghost.y;
      const distG = Math.hypot(dxG, dyG);
      // Modo de fuga ou perseguição
      if (powerUpActive) {
        ghost.x -= (dxG / distG) * ghost.speed;
        ghost.y -= (dyG / distG) * ghost.speed;
        if (ghost.x < ghost.radius) ghost.x = ghost.radius;
        if (ghost.x > canvas.width - ghost.radius) ghost.x = canvas.width - ghost.radius;
        if (ghost.y < ghost.radius) ghost.y = ghost.radius;
        if (ghost.y > canvas.height - ghost.radius) ghost.y = canvas.height - ghost.radius;
      } else {
        if (distG > 5) {
          ghost.x += (dxG / distG) * ghost.speed;
          ghost.y += (dyG / distG) * ghost.speed;
        }
      }
      // Toca som de tensão se fantasma estiver próximo
      if (distG < 150 && !powerUpActive) {
        startGhostTensionSound();
        updateGhostTensionSound(distG);
      } else {
        stopGhostTensionSound();
      }
      // Colisão com fantasma (só se não estiver em modo power-up)
      if (distG < pacManRadius + ghost.radius && !powerUpActive) {
        stopGhostTensionSound();
        resetGame();
        requestAnimationFrame(loop);
        return;
      }
      // Animação da boca
      mouthAngle += mouthOpen ? 0.02 : -0.02;
      if (mouthAngle > 0.4) mouthOpen = false;
      if (mouthAngle < 0.1) mouthOpen = true;
      // Desenha dots
      dots.forEach(dot => {
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, dotRadius, 0, Math.PI * 2);
        ctx.fillStyle = cores.dot;
        ctx.fill();
      });
      // Colisão com dots
      for (let i = dots.length - 1; i >= 0; i--) {
        const dx = dots[i].x - pacManX;
        const dy = dots[i].y - pacManY;
        const dist = Math.hypot(dx, dy);
        if (dist < pacManRadius + dotRadius) {
          dots.splice(i, 1);
          score++;
          scoreElement.textContent = `Pontos: ${score}`;
        }
      }
      if (dots.length === 0) {
        setTimeout(() => {
          createDots();
          if (!powerUpActive && !powerUpVisible) spawnPowerUp();
        }, 500);
      }
      // Desenha Power-up
      if (powerUpVisible) {
        ctx.beginPath();
        ctx.arc(powerUp.x, powerUp.y, powerUpRadius, 0, Math.PI * 2);
        ctx.fillStyle = cores.amarelo;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(powerUp.x, powerUp.y);
        ctx.lineTo(powerUp.x + 50, powerUp.y - 50); // Raio direito
        ctx.strokeStyle = cores.vermelho;
        ctx.lineWidth = 5;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(powerUp.x, powerUp.y, powerUpRadius * 1.2, 0, Math.PI * 2);
        ctx.strokeStyle = cores.azul;
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      // Colisão com Power-up
      if (powerUpVisible) {
        const dxP = powerUp.x - pacManX;
        const dyP = powerUp.y - pacManY;
        const distP = Math.hypot(dxP, dyP);
        if (distP < pacManRadius + powerUpRadius) {
          powerUpVisible = false;
          powerUpActive = true;
          powerUpTimer = 5;
          messageElement.textContent = "Fantasma fugindo!";
          setTimeout(() => { messageElement.textContent = ""; }, 1000);
          // 🎵 Som de coleta
          playSound(600, 0.15, 'square', 0.3);
          playSound(800, 0.1, 'sine', 0.2); // Efeito "ping"
          // 💥 Explosão de partículas
          explode(powerUp.x, powerUp.y, cores.amarelo, 20);
        }
      }
      // Respawn aleatório do power-up
      if (!powerUpVisible && Math.random() < 0.002 && !powerUpActive && dots.length > 5) {
        spawnPowerUp();
      }
      // Atualiza partículas
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1; // Gravidade leve
        p.alpha -= p.decay;
        if (p.alpha <= 0) {
          particles.splice(i, 1);
          continue;
        }
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = `${p.color}${Math.floor(p.alpha * 255).toString(16).padStart(2, '0')}`;
        ctx.fill();
      }
      // Desenha Pac-Man
      ctx.beginPath();
      ctx.arc(pacManX, pacManY, pacManRadius, mouthAngle * Math.PI, (2 - mouthAngle) * Math.PI);
      ctx.lineTo(pacManX, pacManY);
      ctx.closePath();
      ctx.fillStyle = cores.preto;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pacManX + 10, pacManY - 10, 3, 0, Math.PI * 2);
      ctx.fillStyle = cores.vermelho;
      ctx.fill();
      // Desenha fantasma
      const ghostColor = powerUpActive ? 
        (Math.floor(Date.now() / 100) % 2 === 0 ? '#0000FF' : '#3333FF') : 
        cores.cinza;
      ctx.beginPath();
      ctx.arc(ghost.x, ghost.y - ghost.radius + 5, ghost.radius - 6, 0, Math.PI * 2);
      ctx.moveTo(ghost.x - ghost.radius, ghost.y);
      const waveHeight = 5;
      const segments = 5;
      const segmentWidth = (2 * ghost.radius) / segments;
      for (let i = 0; i <= segments; i++) {
        const x = ghost.x - ghost.radius + i * segmentWidth;
        const y = ghost.y + ((i % 2) === 0 ? waveHeight : 0);
        ctx.lineTo(x, y);
      }
      ctx.lineTo(ghost.x + ghost.radius, ghost.y);
      ctx.lineTo(ghost.x + ghost.radius, ghost.y - ghost.radius + 5);
      ctx.arc(ghost.x, ghost.y - ghost.radius + 5, ghost.radius - 6, 0, Math.PI, true);
      ctx.fillStyle = ghostColor;
      ctx.fill();
      // Olhos
      ctx.beginPath();
      ctx.arc(ghost.x - 8, ghost.y - 10, 4, 0, Math.PI * 2);
      ctx.arc(ghost.x + 8, ghost.y - 10, 4, 0, Math.PI * 2);
      ctx.fillStyle = 'white';
      ctx.fill();
      const pupilX = powerUpActive ? 0 : 2;
      ctx.beginPath();
      ctx.arc(ghost.x - 8 + pupilX, ghost.y - 12, 2, 0, Math.PI * 2);
      ctx.arc(ghost.x + 8 + pupilX, ghost.y - 12, 2, 0, Math.PI * 2);
      ctx.fillStyle = powerUpActive ? 'white' : 'blue';
      ctx.fill();
      requestAnimationFrame(loop);
    }
    loop();
    // Tela inicial
    const startScreen = document.getElementById('startScreen');
    startScreen.addEventListener('click', () => {
      startScreen.style.display = 'none';
      canvas.style.display = 'block';
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    });
  </script>
</body>
</html>
